import { Directive, Input, Optional, Host, Self } from '@angular/core';
import { FileUploadComponent } from '../components/multiple-file-upload/file-upload.component';
import { SimpleFileUploadComponent } from '../components/simple-file-upload/simple-file-upload.component';
export class FilesNativeDirective {
    constructor(fileUpload, simpleFileUpload) {
        this.nativeValue = null;
        this.fileUpload = null;
        this.fileUpload = fileUpload || simpleFileUpload;
    }
    set native(isNative) {
        if (typeof isNative === 'string' && (isNative === 'true' || isNative === 'false')) {
            this.nativeValue = JSON.parse(isNative.toLowerCase());
        }
        else if (typeof isNative === 'boolean') {
            this.nativeValue = isNative;
        }
        else {
            throw Error(`Provided value in directive [native]="${isNative}" is not boolean.`);
        }
    }
    ngAfterViewInit() {
        this.enableNative(this.nativeValue);
    }
    ngOnChanges(changes) {
        if ('native' in changes && changes['native'].currentValue !== changes['native'].previousValue) {
            this.enableNative(this.nativeValue);
        }
    }
    enableNative(isNative) {
        if (this.fileUpload && this.fileUpload.control) {
            this.fileUpload.control.native(isNative);
        }
    }
}
FilesNativeDirective.decorators = [
    { type: Directive, args: [{
                selector: 'file-upload[native]',
                host: { '[attr.native]': 'native ? native : null' }
            },] }
];
FilesNativeDirective.ctorParameters = () => [
    { type: FileUploadComponent, decorators: [{ type: Optional }, { type: Host }, { type: Self }] },
    { type: SimpleFileUploadComponent, decorators: [{ type: Optional }, { type: Host }, { type: Self }] }
];
FilesNativeDirective.propDecorators = {
    native: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF0aXZlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lwbGFiL25neC1maWxlLXVwbG9hZC9zcmMvbGliL2RpcmVjdGl2ZXMvbmF0aXZlLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBaUIsUUFBUSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQTRCLE1BQU0sZUFBZSxDQUFDO0FBQ2hILE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDBEQUEwRCxDQUFDO0FBQy9GLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLCtEQUErRCxDQUFDO0FBUTFHLE1BQU0sT0FBTyxvQkFBb0I7SUFpQjdCLFlBQ2dDLFVBQStCLEVBQy9CLGdCQUEyQztRQWpCbkUsZ0JBQVcsR0FBbUIsSUFBSSxDQUFDO1FBYTFCLGVBQVUsR0FBb0QsSUFBSSxDQUFDO1FBS2hGLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxJQUFJLGdCQUFnQixDQUFDO0lBQ3JELENBQUM7SUFqQkQsSUFDVyxNQUFNLENBQUMsUUFBMEI7UUFDeEMsSUFBSSxPQUFPLFFBQVEsS0FBSyxRQUFRLElBQUksQ0FBQyxRQUFRLEtBQUssTUFBTSxJQUFJLFFBQVEsS0FBSyxPQUFPLENBQUMsRUFBRTtZQUMvRSxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7U0FDekQ7YUFBTSxJQUFJLE9BQU8sUUFBUSxLQUFLLFNBQVMsRUFBRTtZQUN0QyxJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQztTQUMvQjthQUFNO1lBQ0gsTUFBTSxLQUFLLENBQUMseUNBQXlDLFFBQVEsbUJBQW1CLENBQUMsQ0FBQztTQUNyRjtJQUNMLENBQUM7SUFVTSxlQUFlO1FBQ2xCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFTSxXQUFXLENBQUMsT0FBc0I7UUFDckMsSUFBSSxRQUFRLElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxZQUFZLEtBQUssT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLGFBQWEsRUFBRTtZQUMzRixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUN2QztJQUNMLENBQUM7SUFFTyxZQUFZLENBQUMsUUFBaUI7UUFDbEMsSUFBSSxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFO1lBQzVDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUM1QztJQUNMLENBQUM7OztZQXpDSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLHFCQUFxQjtnQkFDL0IsSUFBSSxFQUFFLEVBQUMsZUFBZSxFQUFFLHdCQUF3QixFQUFDO2FBQ3BEOzs7WUFSUSxtQkFBbUIsdUJBMkJuQixRQUFRLFlBQUksSUFBSSxZQUFJLElBQUk7WUExQnhCLHlCQUF5Qix1QkEyQnpCLFFBQVEsWUFBSSxJQUFJLFlBQUksSUFBSTs7O3FCQWY1QixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgU2ltcGxlQ2hhbmdlcywgT3B0aW9uYWwsIEhvc3QsIFNlbGYsIE9uQ2hhbmdlcywgQWZ0ZXJWaWV3SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBGaWxlVXBsb2FkQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50cy9tdWx0aXBsZS1maWxlLXVwbG9hZC9maWxlLXVwbG9hZC5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBTaW1wbGVGaWxlVXBsb2FkQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50cy9zaW1wbGUtZmlsZS11cGxvYWQvc2ltcGxlLWZpbGUtdXBsb2FkLmNvbXBvbmVudCc7XHJcblxyXG5cclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICdmaWxlLXVwbG9hZFtuYXRpdmVdJyxcclxuICAgIGhvc3Q6IHsnW2F0dHIubmF0aXZlXSc6ICduYXRpdmUgPyBuYXRpdmUgOiBudWxsJ31cclxufSlcclxuZXhwb3J0IGNsYXNzIEZpbGVzTmF0aXZlRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25DaGFuZ2VzIHtcclxuXHJcbiAgICBwcml2YXRlIG5hdGl2ZVZhbHVlOiBib29sZWFuIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIHB1YmxpYyBzZXQgbmF0aXZlKGlzTmF0aXZlOiBib29sZWFuIHwgc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpc05hdGl2ZSA9PT0gJ3N0cmluZycgJiYgKGlzTmF0aXZlID09PSAndHJ1ZScgfHwgaXNOYXRpdmUgPT09ICdmYWxzZScpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmF0aXZlVmFsdWUgPSBKU09OLnBhcnNlKGlzTmF0aXZlLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlzTmF0aXZlID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgdGhpcy5uYXRpdmVWYWx1ZSA9IGlzTmF0aXZlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBQcm92aWRlZCB2YWx1ZSBpbiBkaXJlY3RpdmUgW25hdGl2ZV09XCIke2lzTmF0aXZlfVwiIGlzIG5vdCBib29sZWFuLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpbGVVcGxvYWQ6IEZpbGVVcGxvYWRDb21wb25lbnQgfCBTaW1wbGVGaWxlVXBsb2FkQ29tcG9uZW50ID0gbnVsbDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBAT3B0aW9uYWwoKSBASG9zdCgpIEBTZWxmKCkgZmlsZVVwbG9hZDogRmlsZVVwbG9hZENvbXBvbmVudCxcclxuICAgICAgICBAT3B0aW9uYWwoKSBASG9zdCgpIEBTZWxmKCkgc2ltcGxlRmlsZVVwbG9hZDogU2ltcGxlRmlsZVVwbG9hZENvbXBvbmVudCkge1xyXG4gICAgICAgIHRoaXMuZmlsZVVwbG9hZCA9IGZpbGVVcGxvYWQgfHwgc2ltcGxlRmlsZVVwbG9hZDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlTmF0aXZlKHRoaXMubmF0aXZlVmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCduYXRpdmUnIGluIGNoYW5nZXMgJiYgY2hhbmdlc1snbmF0aXZlJ10uY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzWyduYXRpdmUnXS5wcmV2aW91c1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlTmF0aXZlKHRoaXMubmF0aXZlVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGVuYWJsZU5hdGl2ZShpc05hdGl2ZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGVVcGxvYWQgJiYgdGhpcy5maWxlVXBsb2FkLmNvbnRyb2wpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxlVXBsb2FkLmNvbnRyb2wubmF0aXZlKGlzTmF0aXZlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl19